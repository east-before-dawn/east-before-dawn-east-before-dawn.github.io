---
title: (2 week Post)  Viterbi 译码器回溯算法核心关键点
Edit: 2020-01-13
mathjax: false
mermaid: false
highlight: false
status: Completed
commentable: flase
tags: Viterbi FEC前向纠错码  IoT 算法 回溯算法
categories: 算法
description: 第一篇帖子
---

# 题外话

心中志不坚定，何必问神仙。

## 2 week Post

本周开始迁移散落在各个博客上面的文章，慢慢归集收纳到这里，进行重新编辑整理美化。

当然以前碰到问题时常懒得进行记录和总结，遗失珍宝。现今回忆重新拾遗。

之后养成持续积累编写技术文档的习惯。

------

# Viterbi 译码器回溯算法核心关键点

# 参考

1. Viterbi 译码器回溯算法实现研究

   电子与信息学报 2007-2 29卷2期 南京理工大学电光学院 王建新 于贵智 

   文章编号：1009-5896(2007)02-0278-05

2. [CC101 技术文档](http://www.ti.com/product/CC1101/technicaldocuments)
   - DN504 -- FEC Implementation (Rev. A)
   - DN507 -- FEC Decoding

------

# 背景

当时候Sub-1GHz RF无线传感器有新的模块，但是历史遗留项目中大量使用CC1101模块。

基于替换成本的考虑，现场更换的人工成本太高，无法进行大规模的更换，只能等待逐年淘汰更换。

需要软件实现CC1101的FEC编解码。

# 关键点

一开始并不知道官方有代码实现，自己实现了编解码，解码是存储所有路径的码距，最后才判决幸存路径。对解码的划窗回溯特性不了解，对其内存使用量造成误判。

在查阅官方代码实现之后，先行进行了验证，但是一直对fecDecode中这段代码百思不得其解，直到查看了上述Paper的回溯网格图，一下就顿悟了。

```c
unsigned short fecDecode(unsigned char *pDecData, unsigned char* pInData, unsigned short nRemBytes)
{
    // If trellis history is sufficiently long, output a byte of decoded data
    if (nPathBits == 32) {
        *pDecData++ = (aPath[iCurrBuf][0] >> 24) & 0xFF;
        nOutputBytes++;
        nPathBits -= 8;
        nRemBytes--;
    } 
}
```

大大优化解码时候内存使用量的关键点在此。

# 存活路径判决

![](https://ftp.bmp.ovh/imgs/2020/01/a75c65023bceb4c5.png)

在划窗的过程中，每个点有两条路径，依据累计码距短进行路径存活判决，在不断的进行判决并且经过足够长的时间，早期划过的窗口中只剩唯一一条存活路径。

# 回溯&特性

> 下诉源于 参考 1.

根据 Viterbi 译码算法，随着译码的进行，经过一定的时间后，各个状态的幸存路径将开始结合，并最终结合于一条幸存路径，图 1 中展示出了 Viterbi 译码算法的这个特性，并根据这个特性，只要经过足够长的时间，根据任一状态向前回溯 M 时刻，会回到相同的状态点，M 为回溯深度，M的大小将决定 SMU 模块中存储块 RAM 的大小，回溯深度的大小通常选定为约束长度 K 的 5～10 倍。

![](https://ftp.bmp.ovh/imgs/2020/01/f0670d59f339e466.png)

---

**PS:**

Viterbi解码算法的思想与其他一些别的领域算法思想有共通之处。故时隔非常久，也标记一下。







